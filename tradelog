#!/bin/bash
export POSIXLY_CORRECT=yes
export LC_ALL=C

COMMAND=""		# Store arguments commands 
LOG_FILES=""		# Input file in .log format
GZ_LOG_FILES="" 	# Input file in .gz archiv
READ_INPUT=""		# Here i ll store input logs 
FILTER=""		# I ll change READ_INPUT using filter	
IS_T_COM_OR_FIL="0"	# Is there command or filter indicator
BEFORE_TIME="9999-99-99" # write only logs before this time 
AFTER_TIME="" 		# WRITE only logs afther this time 
WIDTH=""	
THICK=""		# Here i store tickers separate by ;
THICK_COUNT="0"		# Increment after every tick

##
# Just printi help and exit with code 0
print_help()
{
	echo "Usage: tradelog [-h|--help]"
	echo "...... tradelog [FILTER...] [COMAND] [LOG...]"
	echo "DATETIME == YYYY-MM-DD HH:MM:SS"
	echo ""
	echo "COMMANDS"
	echo ".. list-tick .... List of stock echange tickers."
	echo ".. profit ....... List of profit from lock positions."
	echo ".. pos .......... List of values current held positions"
	echo ".. last-price ... Print last value of every known thicker."
	echo ".. hist-ord ..... List history of transaction by thicker."
	echo ".. graph-pos .... Shov value graph of thicker. "
	echo "FILTER"
	echo ". -a DATETIME ... Only records after this date."
	echo ". -b DATETIME ... Only records before this date."
	echo ". -t TICKER ..... Only records with given thicker. You can specify multiple thickers."
	echo ". -w WIDTH ...... Define width of longest row. w > 0"

	exit 0
}


##
#
list_tick_comm()
{
	echo ""
}

##
#
profit_comm()
{
	echo ""
}


##
#
pos_comm()
{
	echo ""
}

##
#
last_price_comm()
{
	echo ""
}


##
#
hist_ord_comm()
{
	echo ""
}

##
#
graph_pos_comm()
{
	echo ""
}

##
# Parse input arguments and COMMANDS 
argument_parser()
{
	if [ "$#" -eq "0" ];then
		return 0	
	fi
	while [ "$#" -gt 0 ]; do

		#COMMAND##################
		case "$1" in #COMMANDS THERE CAN BE ONLY ONE 
		list-tick | pos | profit | last-price | hist-ord | graph-pos )
			
			if [ "$IS_T_COM_OR_FIL" -eq "1" ]; then
				echo "ERROR Multiple commands are not possible." >&2 
				exit 2	
			fi
			COMMAND="$1"
			IS_T_COM_OR_FIL="1"	# Is there command or filter indicator
			shift   #argmunet co našel provede a záhodí a nyní má index číslo 1 argmunet číslo 2 protože se to posune 
			;;
	
		#HELP###############
		-h)
			print_help
			;;
		--help)
			print_help
			;;
		#FILTERS#################	
		-a) #after DATETIME="YYYY-MM-DD HH:MM:SS"
			if ! [ "$(date -d "$2" +"%F %T" 2> /dev/null)" = "$2" ]; then
				echo "ERROR date should be in YYYY-MM-DD HH:DD:SS format." >&2 
				exit 2	
			fi
			IS_T_COM_OR_FIL="1"	# Is there command or filterr 
			AFTER_TIME=$2	
			shift
			shift
			;;
		-b) #before DATETIME
			if ! [ "$(date -d "$2" +"%F %T" 2> /dev/null)" = "$2" ]; then
				echo "ERROR date should be in YYYY-MM-DD HH:DD:SS format." >&2 
				exit 2	
			fi
			IS_T_COM_OR_FIL="1"	# Is there command or filter indicator
			BEFORE_TIME="$2"	# write only logs before this time 
			shift
			shift
			;;
		-t) #ticker
			if [ -z "$2" ]; then
				echo "ERROR missing argument after -t" >&2 
				exit 2	
			fi
			IS_T_COM_OR_FIL="1"	# Is there command or filter indicator
			THICK="$THICK;$2"
			THICK_COUNT=`echo "$THICK_COUNT + 1" | bc`		# Increment after every tick
			shift
			shift
			;;

		-w) #width
			if [ $2 -gt "0" ]; then
				WIDTH="$2"
			fi
			IS_T_COM_OR_FIL="1"	# Is there command or filter indicator
			shift
			shift
			;;
		
		#LOG#################
		*) #GETING LOG FILES THERE CAN BE MULTIPLE 
			if [ `echo  $1 | grep "\.gz"` ]; then  	#if file ends with .gz
				GZ_LOG_FILES="$1 $GZ_LOG_FILES"		
			else
				LOG_FILES="$1 $LOG_FILES"
			fi
			shift
			;;

		esac
		
	done
}

##
# Check if inputs files exist. 
bad_argument_error()
{

	if [ ! -f ${GZ_LOG_FILES} ]; then 
		echo "error file doesnt exist." >&2  
		exit 1	
	fi
	if [ ! -f ${LOG_FILES} ]; then
		echo "error file doesnt exist." >&2 
		exit 1	
	fi
	return 0
}
##
# If there are no params it store input from stdin to READ_INPUT
# else it store from given files 
store_input()
{
	
	# IF THERE ARE NO PARRAMETERS i ll store stdin
	if [ -z "$COMMAND" ] && [ -z "$LOG_FILES" ] && [ -z "$GZ_LOG_FILES" ]; then
		if [ $IS_T_COM_OR_FIL -eq "1" ]; then
			echo "ERROR You have to specify ticker ater -t or If there is input from stdin u cant add commands or filters." >&2 
		else
			READ_INPUT="${1:-/dev/stdin}"
			READ_INPUT=$(cat "$READ_INPUT") 
		fi
	elif [ ! -z "$LOG_FILES" ] && [ ! -z "$GZ_LOG_FILES" ]; then
		READ_INPUT=$(gzip -d -c $GZ_LOG_FILES && cat $LOG_FILES)
	elif [ ! -z "$GZ_LOG_FILES" ]; then
		READ_INPUT=$(gzip -d -c $GZ_LOG_FILES)
	else
		READ_INPUT=$(cat $LOG_FILES)
	fi
	READ_INPUT=$(echo "$READ_INPUT" | sort -u) 
	
}

##
# Just call propriate command based on $COMMAND
call_command()
{
	case $COMMAND in

		list-tick)
			echo "list-tick"
			;;
		pos)
			echo "pos"
			;;
		profit)
			echo "profit"
			;;
		last-price)
			echo "last-price"
			;;
		hist-ord)
			echo "hist-ord"
			;;
		graph-pos)
			echo "graph-graph"
			;;
		*)
			;;

	esac
	return 0	
}

debug_tempo()
{
	echo "command: $COMMAND" >&2
	echo "gz_l_f:  $GZ_LOG_FILES" >&2
	echo "l_f>     $LOG_FILES" >&2
	echo "aft:     $AFTER_TIME" >&2
	echo "bft:     $BEFORE_TIME" >&2
	echo "width:   $WIDTH" >&2
	echo "thick:   $THICK" >&2
	echo "thick_c: $THICK_COUNT" >&2
}


argument_parser "$@" 		# Parse arguments and store them.
bad_argument_error		# If program has bad arguments it ll exit with error
store_input			# Store inputs to READ_INPUT 

#FILTER SECTION #################################
# Filter olny before and after time 
FILTER=`echo "$READ_INPUT" | awk -F ';' -v a="$BEFORE_TIME" '\$1 < a {print \$0}'`
READ_INPUT="$FILTER"
FILTER=`echo "$READ_INPUT" | awk -F ';' -v a="$AFTER_TIME" '\$1 > a {print \$0}'`
READ_INPUT="$FILTER"

#Filter by given ticker
if ! [ -z "$THICK" ]; then #if THICK is not empty

	FILTER_SUM=""
	# For every ticker in THICK
	for ((i=2; i <= $THICK_COUNT+1; i++)); do
		one_thick=`echo $THICK | cut -d ";" -f $i`
		FILTER=`echo "$READ_INPUT" | awk -F ';' -v a="$one_thick" '\$2 == a {print \$0}'`
		FILTER_SUM="$FILTER_SUM$FILTER"
	done
	READ_INPUT="$FILTER_SUM"
fi
#TODO WIDTH FILTER
##################################################

call_command # Just call propriate command based on $COMMAND


echo "$READ_INPUT"
debug_tempo 		# Giv debug information. 





