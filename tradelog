#!/bin/bash
export POSIXLY_CORRECT=yes
export LC_ALL=C

COMMAND=""		# Store arguments commands 
LOG_FILES=""		# Input file in .log format
GZ_LOG_FILES="" 	# Input file in .gz archiv
READ_INPUT=""		# Here i ll store input logs 
FILTER=""		# I ll change READ_INPUT using filter	
BEFORE_TIME="9999-99-99" # write only logs before this time 
AFTER_TIME="" 		# WRITE only logs afther this time 
WIDTH=""	
THICK=""		# Here i store tickers separate by ;
THICK_COUNT="0"		# Increment after every tick
IS_T_COM="0"		# Is there command or filter indicator

##
# Just printi help and exit with code 0
print_help()
{
	echo "Usage: tradelog [-h|--help]"
	echo "...... tradelog [FILTER...] [COMAND] [LOG...]"
	echo "DATETIME == YYYY-MM-DD HH:MM:SS"
	echo ""
	echo "Log format:"
	echo "DATE TIME;TICKER;TYPE OF TRANSACTION;PRICE;CURRENCY;AMMOUT;ID"
	echo ""
	echo "COMMANDS"
	echo ".. list-tick .... List of stock unique echange tickers in given file."
	echo ".. profit ....... List of profit from lock positions."
	echo ".. pos .......... List of values current held positions"
	echo ".. last-price ... Print last value of every known thicker."
	echo ".. hist-ord ..... List history of transaction by thicker."
	echo ".. graph-pos .... Shov value graph of thicker. "
	echo "FILTER"
	echo ". -a DATETIME ... Only records after this date."
	echo ". -b DATETIME ... Only records before this date."
	echo ". -t TICKER ..... Only records with given thicker. You can specify multiple thickers."
	echo ". -w WIDTH ...... Define width of longest row. w > 0"

	exit 0
}


##
# List unique tickers that are in log
list_tick_comm()
{
	FILTER=`echo "$READ_INPUT" | awk -F ';' '{print \$2}'`
	READ_INPUT="$FILTER"	
	READ_INPUT=$(echo "$READ_INPUT" | sort -u) 
}

##
# Write sum of profits.
# Profit = sum of sell transaction - sum of buy transaction 
profit_comm()
{
	filter1=`echo "$READ_INPUT" | awk -F ';' -v a="sell" '\$3 == a {print \$0}'`
	filter2=`echo "$READ_INPUT" | awk -F ';' -v a="buy" '\$3 == a {print \$0}'`

	SUM1=`echo "$filter1" | awk -F ';' '{value = $4 * $6}{sum += value}END{printf("%f.16", sum)}'`
	SUM2=`echo "$filter2" | awk -F ';' '{value = $4 * $6}{sum += value}END{printf("%f.16", sum)}'`
	
	filter1="$SUM1;$SUM2"
	SUM1=`echo "$filter1" | awk -F ';' '{value = $1 - $2}END{printf("%.2f",value)}'`
	
	echo "$SUM1"
	exit 0
}

##
#
pos_comm()
{
	#first get thickers and count them 
	ticker=`echo "$READ_INPUT" | awk -F ';' '{print \$2}'`
	ticker=$(echo "$ticker" | sort -u) 
	
	sum_ticker=`echo "$ticker" | wc -l`
	
	for ((i=1; i <= $sum_ticker; i++)); do    #walk throught tickers 
		t=`echo "$ticker" | sed -n "$i"p` #get one ticker  
		
		# If ticker match with t sum it and print it 
		filer_ticker=`echo "$READ_INPUT" | awk -F ';' -v a="$t" '\$2 == a {print \$0}'`

		filter_sell=`echo "$filer_ticker" | awk -F ';' -v a="sell" '\$3 == a {print \$0}'`  #sell value 
		filter_buy=`echo "$filer_ticker" | awk -F ';' -v a="buy" '\$3 == a {print \$0}'`  #sell value 
		
		SUM1=`echo "$filter_buy" | awk -F ';' '{value = $4 * $6}{sum += value}END{printf("%f.16", sum)}'`
		SUM2=`echo "$filter_sell" | awk -F ';' '{value = $4 * $6}{sum += value}END{printf("%f.16", sum)}'`

		filter1="$SUM1;$SUM2"
		SUM1=`echo "$filter1" | awk -F ';' '{value = $1 - $2}END{printf("%05.22f",value)}'`
		FILTER_SUM=`echo "$FILTER_SUM" & echo "$t:$SUM1"`
	done

	#TODO nahradit %12 promenou s nejdelsim cislem
	d=`echo "$FILTER_SUM" | sort -n -r -t ':' -k 2`
	echo "$d" | awk -F ':' '{printf("%-9s : %12.2f  \n"),$1, $2}'
	
	exit 0
}

##
#
last_price_comm()
{
	echo ""
}


##
#
hist_ord_comm()
{
	echo ""
}

##
 #
graph_pos_comm()
{
	echo ""
}

##
# Parse input arguments and COMMANDS 
argument_parser()
{
	if [ "$#" -eq "0" ];then
		return 0	
	fi
	while [ "$#" -gt 0 ]; do

		#COMMAND##################
		case "$1" in #COMMANDS THERE CAN BE ONLY ONE 
		list-tick | pos | profit | last-price | hist-ord | graph-pos )
			
			if [ "$IS_T_COM" -eq "1" ]; then
				echo "ERROR Multiple commands are not possible." >&2 
				exit 2	
			fi
			COMMAND="$1"
			IS_T_COM="1"	# Is there command or filter indicator
			shift   #argmunet co našel provede a záhodí a nyní má index číslo 1 argmunet číslo 2 protože se to posune 
			;;
	
		#HELP###############
		-h)
			print_help
			;;
		--help)
			print_help
			;;
		#FILTERS#################	
		-a) #after DATETIME="YYYY-MM-DD HH:MM:SS"
			if ! [ "$(date -d "$2" +"%F %T" 2> /dev/null)" = "$2" ]; then
				echo "ERROR date should be in YYYY-MM-DD HH:DD:SS format." >&2 
				exit 2	
			fi
			IS_T_COM_OR_FIL="1"	# Is there command or filterr 
			AFTER_TIME=$2	
			shift
			shift
			;;
		-b) #before DATETIME
			if ! [ "$(date -d "$2" +"%F %T" 2> /dev/null)" = "$2" ]; then
				echo "ERROR date should be in YYYY-MM-DD HH:DD:SS format." >&2 
				exit 2	
			fi
			BEFORE_TIME="$2"	# write only logs before this time 
			shift
			shift
			;;
		-t) #ticker
			if [ -z "$2" ]; then
				echo "ERROR missing argument after -t" >&2 
				exit 2	
			fi
			THICK="$THICK;$2"
			THICK_COUNT=`echo "$THICK_COUNT + 1" | bc`		# Increment after every tick
			shift
			shift
			;;

		-w) #width
			if [ $2 -gt "0" ]; then
				WIDTH="$2"
			fi
			shift
			shift
			;;
		
		#LOG#################
		*) #GETING LOG FILES THERE CAN BE MULTIPLE 
			if [ `echo  $1 | grep "\.gz"` ]; then  	#if file ends with .gz
				GZ_LOG_FILES="$1 $GZ_LOG_FILES"		
			else
				LOG_FILES="$1 $LOG_FILES"
			fi
			shift
			;;

		esac
		
	done
}

##
# Check if inputs files exist. 
bad_argument_error()
{

	if [ ! -f ${GZ_LOG_FILES} ]; then 
		echo "error file doesnt exist." >&2  
		exit 1	
	fi
	if [ ! -f ${LOG_FILES} ]; then
		echo "error file doesnt exist." >&2 
		exit 1	
	fi
	return 0
}
##
# If there are no params it store input from stdin to READ_INPUT
# else it store from given files 
store_input()
{
	
	# IF THERE ARE NO PARRAMETERS i ll store stdin
	if [ -z "$COMMAND" ] && [ -z "$LOG_FILES" ] && [ -z "$GZ_LOG_FILES" ]; then
		if [ $IS_T_COM_OR_FIL -eq "1" ]; then
			echo "ERROR You have to specify ticker ater -t or If there is input from stdin u cant add commands or filters." >&2 
		else
			READ_INPUT="${1:-/dev/stdin}"
			READ_INPUT=$(cat "$READ_INPUT") 
		fi
	elif [ ! -z "$LOG_FILES" ] && [ ! -z "$GZ_LOG_FILES" ]; then
		READ_INPUT=$(gzip -d -c $GZ_LOG_FILES && cat $LOG_FILES)
	elif [ ! -z "$GZ_LOG_FILES" ]; then
		READ_INPUT=$(gzip -d -c $GZ_LOG_FILES)
	else
		READ_INPUT=$(cat $LOG_FILES)
	fi
	READ_INPUT=$(echo "$READ_INPUT" | sort -u) 
	
}

##
# Just call propriate command based on $COMMAND
call_command()
{
	
	case $COMMAND in

		list-tick)
			list_tick_comm
			;;
		pos)
			pos_comm
			;;
		profit)
			profit_comm
			;;
		last-price)
			last_price_comm
			;;
		hist-ord)
			hist_ord_comm
			;;
		graph-pos)
			graph_pos_comm
			;;
		*)
			;;

	esac
}

debug_tempo()
{
	echo "command: $COMMAND" >&2
	echo "gz_l_f:  $GZ_LOG_FILES" >&2
	echo "l_f>     $LOG_FILES" >&2
	echo "aft:     $AFTER_TIME" >&2
	echo "bft:     $BEFORE_TIME" >&2
	echo "width:   $WIDTH" >&2
	echo "thick:   $THICK" >&2
	echo "thick_c: $THICK_COUNT" >&2
}


argument_parser "$@" 		# Parse arguments and store them.
bad_argument_error		# If program has bad arguments it ll exit with error
store_input			# Store inputs to READ_INPUT 

#FILTER SECTION #################################
# Filter olny before and after time 
FILTER=`echo "$READ_INPUT" | awk -F ';' -v a="$BEFORE_TIME" '\$1 < a {print \$0}'`
READ_INPUT="$FILTER"
FILTER=`echo "$READ_INPUT" | awk -F ';' -v a="$AFTER_TIME" '\$1 > a {print \$0}'`
READ_INPUT="$FILTER"

#Filter by given ticker
if ! [ -z "$THICK" ]; then #if THICK is not empty

	FILTER_SUM=""
	# For every ticker in THICK
	for ((i=2; i <= $THICK_COUNT+1; i++)); do
		one_thick=`echo $THICK | cut -d ";" -f $i`
		FILTER=`echo "$READ_INPUT" | awk -F ';' -v a="$one_thick" '\$2 == a {print \$0}'`
		FILTER_SUM=`echo "$FILTER_SUM" & echo "$FILTER"`
	done
	READ_INPUT="$FILTER_SUM"
fi
#TODO WIDTH FILTER
##################################################

call_command 		# Just call propriate command based on $COMMAND


echo "$READ_INPUT"
debug_tempo 		# Giv debug information. 




